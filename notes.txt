- why redux:
one store
reduced boilerplate
isomorphic/universal friendly
immutable store
hot reloading
time-travel debugging
small

react-slingshot

React classes in es6:
no autobind
proptypes are declared separately
default props declared separately
set initial state in constructor

React stateless component in es6:
const HelloWorld = () => {
  ...
}

benefits of stateless:
no class needed
avoid 'this' keyword
enforced best practices
high signal-to-noise
enhanced code completion/intellisense
bloated components are obvious
easier to understand

use stateless components whenever possible

use class components when you need:
local state
refs
lifecycle hooks
child functions (for performance)

use stateless components everywhere else

Container vs presentation components:

container:
little to no markup
pass data actions down
know about redux
often stateful

presentation:
nearly all markup
don't contain much markup
receive data and actions via props
doesn't know about redux
typically functional components

More complex apps are better for React and Redux. There is a significant setup

Redux good for:
complex data flows
inter-component communication
non-hierarchical data
many actions
same data in multiple places

store:
local client side data base
dispatch an action that notifies the components

3 core principles of redux:
one immutable store
actions trigger changes
reducers update state

flux vs redux:
common:
unidirectional data flow
utilize a finite set of actions
both utilize stores (redux just one)

differences:
reducers are new. pure functions
containers are react components with specific use
immutability: redux store is immutable

Flux:
action -> dispatcher -> store -> react
^                                   |
|____________________________________

Redux:
action -> store -> react
^           ||        |
|        reducers     |
_______________________

Flux:
Stores contain state and change logic
multiple stores
flat and disconnected stores
singleton dispatcher
react components subscribe to stores
state is mutated

Redux:
Store and change logic are separate
one store
single store with hierarchical reducers
no dispatcher
container components utilize connect
state is immutable

action:
  {type: RATE_COURSE, rating: 5}
reducers:
  function appReducer(state= defaultState, action {
    switch statement
  })
  returns updates state
store:
React:

Actions, Stores, Immutability, Reducers:

Actions:
must have a type, all else is options

action creator:
rateCourse(rating) {
  return {type: RATE_COURSE, rating: rating}
}

action creators are named after type of action by convention

Store:
let store = createStore(reducer);
single responsibility principle
just stores data
store.dispatch(action)
store.subscribe(listener)
store.getState()
replaceReducer(nextReducer)
you can't change store directly
actions handle by reducers

Immutability:
To change state, return a new object
Some types in js are already immutable: Number, String, Boolean, Undefined, Null
Mutable: Objects, Arrays, Functions

Copy:
Signature: Objext.assign(target, ...sources)
Example: Object.assign({}, state, {role: 'admin'});
(deep copy)
needs babel-polyfill

Immutability allows for clarity
Immutability improves performance
Immutability helps for debugging

Handling immutability:
Object.assign
spread operator

How to enforce immutability:
redux-immutable-state-invariant library
immutable.js

Reducers:

function myReducer(state, action) {
  //Return new state
}

function myReducer(state, action) {
  switch (action.type) {
    case 'INCREMENT_COUNTER':
      return (Object.assign(
        {},
        state,
        {counter: state.counter + 1}
      ))
  }
}

Reducers must be pure functions. Never:
mutate arguments
perform side effects
call non-pure functions

1 store, multiple reducers
all reducers are called on each dispatch
always return untouched state if nothing happens
actions and reducers are not one to one

Connecting React to redux:
Container vs. Presentation Components:
React-Redux:
  Provider
  connect

2 Component types: Container vs. Presentation Components
Container:
smart
focus on how things work
handle data and state
aware of redux
subscribe to redux state
dispatch redux actions
generated by react-redux

Presentation:
dumb
focus on how things look
receive data and props only
unaware of redux
read data from props
invoke callbacks on props
written by hand

React-redux library:
companion library for redux

provider:
attaches app to store

connect:
creates container components

Provider:
<Provider store={this.props.store}>
  <App />
</Provider>

Connect:
wraps our component so its connected to the Redux store

function mapStateToProps(state, ownProps) {
  return {appState: state.authorReducer};
}

export default connect(
  mapStateToProps //specifies state
  mapDispatchToProps //specifies action
)(AuthorPage);

Benefits compared to flux:
no manual unsubscribe
no lifecycle methods
declare what subset of state you want
enhance performance for free

mapStateToProps:
what state should i expose to props?
returns an object
memoize for performance
like caching for function calls

mapDispatchToProps:
what actions we want to expose as props?

function mapDispatchToProps(dispatch) {
  return {
    actions: bindActionsCreators(actions, dispatch)
  }
}

React doesn't autobind in es6

5 major pieces of a container component
- constructor, initialize state, bind functions
- child functions
- render function
- proptypes for validation
- redux connect and related functions

Async in redux
we'll use a mock API
start before the API exists
independence
backup plan
ultra-fast
tests slowness
aids testing
point to the real API later

Redux Async Libraries
- redux-thunk
- redux-promise
- redux-saga

Thunk vs. Sagas

Thunks:
functions
clunky to test
easy to learn

Sagas:
generators
easy to test
hard to learn





























sfd
